// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/polshe-v/microservices_chat_server/internal/model"
)

// ChatServiceMock implements service.ChatService
type ChatServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConnect          func(chatID string, username string, stream model.Stream) (err error)
	inspectFuncConnect   func(chatID string, username string, stream model.Stream)
	afterConnectCounter  uint64
	beforeConnectCounter uint64
	ConnectMock          mChatServiceMockConnect

	funcCreate          func(ctx context.Context, chat *model.Chat) (s1 string, err error)
	inspectFuncCreate   func(ctx context.Context, chat *model.Chat)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mChatServiceMockCreate

	funcDelete          func(ctx context.Context, id string) (err error)
	inspectFuncDelete   func(ctx context.Context, id string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mChatServiceMockDelete

	funcInitChannels          func(ctx context.Context) (err error)
	inspectFuncInitChannels   func(ctx context.Context)
	afterInitChannelsCounter  uint64
	beforeInitChannelsCounter uint64
	InitChannelsMock          mChatServiceMockInitChannels

	funcSendMessage          func(ctx context.Context, chatID string, message *model.Message) (err error)
	inspectFuncSendMessage   func(ctx context.Context, chatID string, message *model.Message)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServiceMockSendMessage
}

// NewChatServiceMock returns a mock for service.ChatService
func NewChatServiceMock(t minimock.Tester) *ChatServiceMock {
	m := &ChatServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConnectMock = mChatServiceMockConnect{mock: m}
	m.ConnectMock.callArgs = []*ChatServiceMockConnectParams{}

	m.CreateMock = mChatServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*ChatServiceMockCreateParams{}

	m.DeleteMock = mChatServiceMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ChatServiceMockDeleteParams{}

	m.InitChannelsMock = mChatServiceMockInitChannels{mock: m}
	m.InitChannelsMock.callArgs = []*ChatServiceMockInitChannelsParams{}

	m.SendMessageMock = mChatServiceMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServiceMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceMockConnect struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockConnectExpectation
	expectations       []*ChatServiceMockConnectExpectation

	callArgs []*ChatServiceMockConnectParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatServiceMockConnectExpectation specifies expectation struct of the ChatService.Connect
type ChatServiceMockConnectExpectation struct {
	mock      *ChatServiceMock
	params    *ChatServiceMockConnectParams
	paramPtrs *ChatServiceMockConnectParamPtrs
	results   *ChatServiceMockConnectResults
	Counter   uint64
}

// ChatServiceMockConnectParams contains parameters of the ChatService.Connect
type ChatServiceMockConnectParams struct {
	chatID   string
	username string
	stream   model.Stream
}

// ChatServiceMockConnectParamPtrs contains pointers to parameters of the ChatService.Connect
type ChatServiceMockConnectParamPtrs struct {
	chatID   *string
	username *string
	stream   *model.Stream
}

// ChatServiceMockConnectResults contains results of the ChatService.Connect
type ChatServiceMockConnectResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConnect *mChatServiceMockConnect) Optional() *mChatServiceMockConnect {
	mmConnect.optional = true
	return mmConnect
}

// Expect sets up expected params for ChatService.Connect
func (mmConnect *mChatServiceMockConnect) Expect(chatID string, username string, stream model.Stream) *mChatServiceMockConnect {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &ChatServiceMockConnectExpectation{}
	}

	if mmConnect.defaultExpectation.paramPtrs != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by ExpectParams functions")
	}

	mmConnect.defaultExpectation.params = &ChatServiceMockConnectParams{chatID, username, stream}
	for _, e := range mmConnect.expectations {
		if minimock.Equal(e.params, mmConnect.defaultExpectation.params) {
			mmConnect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConnect.defaultExpectation.params)
		}
	}

	return mmConnect
}

// ExpectChatIDParam1 sets up expected param chatID for ChatService.Connect
func (mmConnect *mChatServiceMockConnect) ExpectChatIDParam1(chatID string) *mChatServiceMockConnect {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &ChatServiceMockConnectExpectation{}
	}

	if mmConnect.defaultExpectation.params != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Expect")
	}

	if mmConnect.defaultExpectation.paramPtrs == nil {
		mmConnect.defaultExpectation.paramPtrs = &ChatServiceMockConnectParamPtrs{}
	}
	mmConnect.defaultExpectation.paramPtrs.chatID = &chatID

	return mmConnect
}

// ExpectUsernameParam2 sets up expected param username for ChatService.Connect
func (mmConnect *mChatServiceMockConnect) ExpectUsernameParam2(username string) *mChatServiceMockConnect {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &ChatServiceMockConnectExpectation{}
	}

	if mmConnect.defaultExpectation.params != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Expect")
	}

	if mmConnect.defaultExpectation.paramPtrs == nil {
		mmConnect.defaultExpectation.paramPtrs = &ChatServiceMockConnectParamPtrs{}
	}
	mmConnect.defaultExpectation.paramPtrs.username = &username

	return mmConnect
}

// ExpectStreamParam3 sets up expected param stream for ChatService.Connect
func (mmConnect *mChatServiceMockConnect) ExpectStreamParam3(stream model.Stream) *mChatServiceMockConnect {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &ChatServiceMockConnectExpectation{}
	}

	if mmConnect.defaultExpectation.params != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Expect")
	}

	if mmConnect.defaultExpectation.paramPtrs == nil {
		mmConnect.defaultExpectation.paramPtrs = &ChatServiceMockConnectParamPtrs{}
	}
	mmConnect.defaultExpectation.paramPtrs.stream = &stream

	return mmConnect
}

// Inspect accepts an inspector function that has same arguments as the ChatService.Connect
func (mmConnect *mChatServiceMockConnect) Inspect(f func(chatID string, username string, stream model.Stream)) *mChatServiceMockConnect {
	if mmConnect.mock.inspectFuncConnect != nil {
		mmConnect.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.Connect")
	}

	mmConnect.mock.inspectFuncConnect = f

	return mmConnect
}

// Return sets up results that will be returned by ChatService.Connect
func (mmConnect *mChatServiceMockConnect) Return(err error) *ChatServiceMock {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &ChatServiceMockConnectExpectation{mock: mmConnect.mock}
	}
	mmConnect.defaultExpectation.results = &ChatServiceMockConnectResults{err}
	return mmConnect.mock
}

// Set uses given function f to mock the ChatService.Connect method
func (mmConnect *mChatServiceMockConnect) Set(f func(chatID string, username string, stream model.Stream) (err error)) *ChatServiceMock {
	if mmConnect.defaultExpectation != nil {
		mmConnect.mock.t.Fatalf("Default expectation is already set for the ChatService.Connect method")
	}

	if len(mmConnect.expectations) > 0 {
		mmConnect.mock.t.Fatalf("Some expectations are already set for the ChatService.Connect method")
	}

	mmConnect.mock.funcConnect = f
	return mmConnect.mock
}

// When sets expectation for the ChatService.Connect which will trigger the result defined by the following
// Then helper
func (mmConnect *mChatServiceMockConnect) When(chatID string, username string, stream model.Stream) *ChatServiceMockConnectExpectation {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	expectation := &ChatServiceMockConnectExpectation{
		mock:   mmConnect.mock,
		params: &ChatServiceMockConnectParams{chatID, username, stream},
	}
	mmConnect.expectations = append(mmConnect.expectations, expectation)
	return expectation
}

// Then sets up ChatService.Connect return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockConnectExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockConnectResults{err}
	return e.mock
}

// Times sets number of times ChatService.Connect should be invoked
func (mmConnect *mChatServiceMockConnect) Times(n uint64) *mChatServiceMockConnect {
	if n == 0 {
		mmConnect.mock.t.Fatalf("Times of ChatServiceMock.Connect mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConnect.expectedInvocations, n)
	return mmConnect
}

func (mmConnect *mChatServiceMockConnect) invocationsDone() bool {
	if len(mmConnect.expectations) == 0 && mmConnect.defaultExpectation == nil && mmConnect.mock.funcConnect == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConnect.mock.afterConnectCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConnect.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Connect implements service.ChatService
func (mmConnect *ChatServiceMock) Connect(chatID string, username string, stream model.Stream) (err error) {
	mm_atomic.AddUint64(&mmConnect.beforeConnectCounter, 1)
	defer mm_atomic.AddUint64(&mmConnect.afterConnectCounter, 1)

	if mmConnect.inspectFuncConnect != nil {
		mmConnect.inspectFuncConnect(chatID, username, stream)
	}

	mm_params := ChatServiceMockConnectParams{chatID, username, stream}

	// Record call args
	mmConnect.ConnectMock.mutex.Lock()
	mmConnect.ConnectMock.callArgs = append(mmConnect.ConnectMock.callArgs, &mm_params)
	mmConnect.ConnectMock.mutex.Unlock()

	for _, e := range mmConnect.ConnectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmConnect.ConnectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConnect.ConnectMock.defaultExpectation.Counter, 1)
		mm_want := mmConnect.ConnectMock.defaultExpectation.params
		mm_want_ptrs := mmConnect.ConnectMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockConnectParams{chatID, username, stream}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmConnect.t.Errorf("ChatServiceMock.Connect got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmConnect.t.Errorf("ChatServiceMock.Connect got unexpected parameter username, want: %#v, got: %#v%s\n", *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.stream != nil && !minimock.Equal(*mm_want_ptrs.stream, mm_got.stream) {
				mmConnect.t.Errorf("ChatServiceMock.Connect got unexpected parameter stream, want: %#v, got: %#v%s\n", *mm_want_ptrs.stream, mm_got.stream, minimock.Diff(*mm_want_ptrs.stream, mm_got.stream))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConnect.t.Errorf("ChatServiceMock.Connect got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConnect.ConnectMock.defaultExpectation.results
		if mm_results == nil {
			mmConnect.t.Fatal("No results are set for the ChatServiceMock.Connect")
		}
		return (*mm_results).err
	}
	if mmConnect.funcConnect != nil {
		return mmConnect.funcConnect(chatID, username, stream)
	}
	mmConnect.t.Fatalf("Unexpected call to ChatServiceMock.Connect. %v %v %v", chatID, username, stream)
	return
}

// ConnectAfterCounter returns a count of finished ChatServiceMock.Connect invocations
func (mmConnect *ChatServiceMock) ConnectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnect.afterConnectCounter)
}

// ConnectBeforeCounter returns a count of ChatServiceMock.Connect invocations
func (mmConnect *ChatServiceMock) ConnectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnect.beforeConnectCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.Connect.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConnect *mChatServiceMockConnect) Calls() []*ChatServiceMockConnectParams {
	mmConnect.mutex.RLock()

	argCopy := make([]*ChatServiceMockConnectParams, len(mmConnect.callArgs))
	copy(argCopy, mmConnect.callArgs)

	mmConnect.mutex.RUnlock()

	return argCopy
}

// MinimockConnectDone returns true if the count of the Connect invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockConnectDone() bool {
	if m.ConnectMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConnectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConnectMock.invocationsDone()
}

// MinimockConnectInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockConnectInspect() {
	for _, e := range m.ConnectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.Connect with params: %#v", *e.params)
		}
	}

	afterConnectCounter := mm_atomic.LoadUint64(&m.afterConnectCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectMock.defaultExpectation != nil && afterConnectCounter < 1 {
		if m.ConnectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.Connect")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.Connect with params: %#v", *m.ConnectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnect != nil && afterConnectCounter < 1 {
		m.t.Error("Expected call to ChatServiceMock.Connect")
	}

	if !m.ConnectMock.invocationsDone() && afterConnectCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.Connect but found %d calls",
			mm_atomic.LoadUint64(&m.ConnectMock.expectedInvocations), afterConnectCounter)
	}
}

type mChatServiceMockCreate struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockCreateExpectation
	expectations       []*ChatServiceMockCreateExpectation

	callArgs []*ChatServiceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatServiceMockCreateExpectation specifies expectation struct of the ChatService.Create
type ChatServiceMockCreateExpectation struct {
	mock      *ChatServiceMock
	params    *ChatServiceMockCreateParams
	paramPtrs *ChatServiceMockCreateParamPtrs
	results   *ChatServiceMockCreateResults
	Counter   uint64
}

// ChatServiceMockCreateParams contains parameters of the ChatService.Create
type ChatServiceMockCreateParams struct {
	ctx  context.Context
	chat *model.Chat
}

// ChatServiceMockCreateParamPtrs contains pointers to parameters of the ChatService.Create
type ChatServiceMockCreateParamPtrs struct {
	ctx  *context.Context
	chat **model.Chat
}

// ChatServiceMockCreateResults contains results of the ChatService.Create
type ChatServiceMockCreateResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mChatServiceMockCreate) Optional() *mChatServiceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for ChatService.Create
func (mmCreate *mChatServiceMockCreate) Expect(ctx context.Context, chat *model.Chat) *mChatServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &ChatServiceMockCreateParams{ctx, chat}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.Create
func (mmCreate *mChatServiceMockCreate) ExpectCtxParam1(ctx context.Context) *mChatServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ChatServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectChatParam2 sets up expected param chat for ChatService.Create
func (mmCreate *mChatServiceMockCreate) ExpectChatParam2(chat *model.Chat) *mChatServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ChatServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.chat = &chat

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ChatService.Create
func (mmCreate *mChatServiceMockCreate) Inspect(f func(ctx context.Context, chat *model.Chat)) *mChatServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ChatService.Create
func (mmCreate *mChatServiceMockCreate) Return(s1 string, err error) *ChatServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ChatServiceMockCreateResults{s1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the ChatService.Create method
func (mmCreate *mChatServiceMockCreate) Set(f func(ctx context.Context, chat *model.Chat) (s1 string, err error)) *ChatServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ChatService.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ChatService.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the ChatService.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mChatServiceMockCreate) When(ctx context.Context, chat *model.Chat) *ChatServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	expectation := &ChatServiceMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &ChatServiceMockCreateParams{ctx, chat},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ChatService.Create return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCreateExpectation) Then(s1 string, err error) *ChatServiceMock {
	e.results = &ChatServiceMockCreateResults{s1, err}
	return e.mock
}

// Times sets number of times ChatService.Create should be invoked
func (mmCreate *mChatServiceMockCreate) Times(n uint64) *mChatServiceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of ChatServiceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mChatServiceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements service.ChatService
func (mmCreate *ChatServiceMock) Create(ctx context.Context, chat *model.Chat) (s1 string, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, chat)
	}

	mm_params := ChatServiceMockCreateParams{ctx, chat}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockCreateParams{ctx, chat}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("ChatServiceMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chat != nil && !minimock.Equal(*mm_want_ptrs.chat, mm_got.chat) {
				mmCreate.t.Errorf("ChatServiceMock.Create got unexpected parameter chat, want: %#v, got: %#v%s\n", *mm_want_ptrs.chat, mm_got.chat, minimock.Diff(*mm_want_ptrs.chat, mm_got.chat))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ChatServiceMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ChatServiceMock.Create")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, chat)
	}
	mmCreate.t.Fatalf("Unexpected call to ChatServiceMock.Create. %v %v", ctx, chat)
	return
}

// CreateAfterCounter returns a count of finished ChatServiceMock.Create invocations
func (mmCreate *ChatServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ChatServiceMock.Create invocations
func (mmCreate *ChatServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mChatServiceMockCreate) Calls() []*ChatServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ChatServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.Create")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to ChatServiceMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mChatServiceMockDelete struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockDeleteExpectation
	expectations       []*ChatServiceMockDeleteExpectation

	callArgs []*ChatServiceMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatServiceMockDeleteExpectation specifies expectation struct of the ChatService.Delete
type ChatServiceMockDeleteExpectation struct {
	mock      *ChatServiceMock
	params    *ChatServiceMockDeleteParams
	paramPtrs *ChatServiceMockDeleteParamPtrs
	results   *ChatServiceMockDeleteResults
	Counter   uint64
}

// ChatServiceMockDeleteParams contains parameters of the ChatService.Delete
type ChatServiceMockDeleteParams struct {
	ctx context.Context
	id  string
}

// ChatServiceMockDeleteParamPtrs contains pointers to parameters of the ChatService.Delete
type ChatServiceMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *string
}

// ChatServiceMockDeleteResults contains results of the ChatService.Delete
type ChatServiceMockDeleteResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mChatServiceMockDelete) Optional() *mChatServiceMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for ChatService.Delete
func (mmDelete *mChatServiceMockDelete) Expect(ctx context.Context, id string) *mChatServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &ChatServiceMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.Delete
func (mmDelete *mChatServiceMockDelete) ExpectCtxParam1(ctx context.Context) *mChatServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ChatServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for ChatService.Delete
func (mmDelete *mChatServiceMockDelete) ExpectIdParam2(id string) *mChatServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ChatServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the ChatService.Delete
func (mmDelete *mChatServiceMockDelete) Inspect(f func(ctx context.Context, id string)) *mChatServiceMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by ChatService.Delete
func (mmDelete *mChatServiceMockDelete) Return(err error) *ChatServiceMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatServiceMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ChatServiceMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the ChatService.Delete method
func (mmDelete *mChatServiceMockDelete) Set(f func(ctx context.Context, id string) (err error)) *ChatServiceMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the ChatService.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the ChatService.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the ChatService.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mChatServiceMockDelete) When(ctx context.Context, id string) *ChatServiceMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	expectation := &ChatServiceMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ChatServiceMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up ChatService.Delete return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockDeleteExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockDeleteResults{err}
	return e.mock
}

// Times sets number of times ChatService.Delete should be invoked
func (mmDelete *mChatServiceMockDelete) Times(n uint64) *mChatServiceMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of ChatServiceMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	return mmDelete
}

func (mmDelete *mChatServiceMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements service.ChatService
func (mmDelete *ChatServiceMock) Delete(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := ChatServiceMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("ChatServiceMock.Delete got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("ChatServiceMock.Delete got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ChatServiceMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ChatServiceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to ChatServiceMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished ChatServiceMock.Delete invocations
func (mmDelete *ChatServiceMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ChatServiceMock.Delete invocations
func (mmDelete *ChatServiceMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mChatServiceMockDelete) Calls() []*ChatServiceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ChatServiceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.Delete with params: %#v", *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.Delete")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Error("Expected call to ChatServiceMock.Delete")
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.Delete but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), afterDeleteCounter)
	}
}

type mChatServiceMockInitChannels struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockInitChannelsExpectation
	expectations       []*ChatServiceMockInitChannelsExpectation

	callArgs []*ChatServiceMockInitChannelsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatServiceMockInitChannelsExpectation specifies expectation struct of the ChatService.InitChannels
type ChatServiceMockInitChannelsExpectation struct {
	mock      *ChatServiceMock
	params    *ChatServiceMockInitChannelsParams
	paramPtrs *ChatServiceMockInitChannelsParamPtrs
	results   *ChatServiceMockInitChannelsResults
	Counter   uint64
}

// ChatServiceMockInitChannelsParams contains parameters of the ChatService.InitChannels
type ChatServiceMockInitChannelsParams struct {
	ctx context.Context
}

// ChatServiceMockInitChannelsParamPtrs contains pointers to parameters of the ChatService.InitChannels
type ChatServiceMockInitChannelsParamPtrs struct {
	ctx *context.Context
}

// ChatServiceMockInitChannelsResults contains results of the ChatService.InitChannels
type ChatServiceMockInitChannelsResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInitChannels *mChatServiceMockInitChannels) Optional() *mChatServiceMockInitChannels {
	mmInitChannels.optional = true
	return mmInitChannels
}

// Expect sets up expected params for ChatService.InitChannels
func (mmInitChannels *mChatServiceMockInitChannels) Expect(ctx context.Context) *mChatServiceMockInitChannels {
	if mmInitChannels.mock.funcInitChannels != nil {
		mmInitChannels.mock.t.Fatalf("ChatServiceMock.InitChannels mock is already set by Set")
	}

	if mmInitChannels.defaultExpectation == nil {
		mmInitChannels.defaultExpectation = &ChatServiceMockInitChannelsExpectation{}
	}

	if mmInitChannels.defaultExpectation.paramPtrs != nil {
		mmInitChannels.mock.t.Fatalf("ChatServiceMock.InitChannels mock is already set by ExpectParams functions")
	}

	mmInitChannels.defaultExpectation.params = &ChatServiceMockInitChannelsParams{ctx}
	for _, e := range mmInitChannels.expectations {
		if minimock.Equal(e.params, mmInitChannels.defaultExpectation.params) {
			mmInitChannels.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInitChannels.defaultExpectation.params)
		}
	}

	return mmInitChannels
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.InitChannels
func (mmInitChannels *mChatServiceMockInitChannels) ExpectCtxParam1(ctx context.Context) *mChatServiceMockInitChannels {
	if mmInitChannels.mock.funcInitChannels != nil {
		mmInitChannels.mock.t.Fatalf("ChatServiceMock.InitChannels mock is already set by Set")
	}

	if mmInitChannels.defaultExpectation == nil {
		mmInitChannels.defaultExpectation = &ChatServiceMockInitChannelsExpectation{}
	}

	if mmInitChannels.defaultExpectation.params != nil {
		mmInitChannels.mock.t.Fatalf("ChatServiceMock.InitChannels mock is already set by Expect")
	}

	if mmInitChannels.defaultExpectation.paramPtrs == nil {
		mmInitChannels.defaultExpectation.paramPtrs = &ChatServiceMockInitChannelsParamPtrs{}
	}
	mmInitChannels.defaultExpectation.paramPtrs.ctx = &ctx

	return mmInitChannels
}

// Inspect accepts an inspector function that has same arguments as the ChatService.InitChannels
func (mmInitChannels *mChatServiceMockInitChannels) Inspect(f func(ctx context.Context)) *mChatServiceMockInitChannels {
	if mmInitChannels.mock.inspectFuncInitChannels != nil {
		mmInitChannels.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.InitChannels")
	}

	mmInitChannels.mock.inspectFuncInitChannels = f

	return mmInitChannels
}

// Return sets up results that will be returned by ChatService.InitChannels
func (mmInitChannels *mChatServiceMockInitChannels) Return(err error) *ChatServiceMock {
	if mmInitChannels.mock.funcInitChannels != nil {
		mmInitChannels.mock.t.Fatalf("ChatServiceMock.InitChannels mock is already set by Set")
	}

	if mmInitChannels.defaultExpectation == nil {
		mmInitChannels.defaultExpectation = &ChatServiceMockInitChannelsExpectation{mock: mmInitChannels.mock}
	}
	mmInitChannels.defaultExpectation.results = &ChatServiceMockInitChannelsResults{err}
	return mmInitChannels.mock
}

// Set uses given function f to mock the ChatService.InitChannels method
func (mmInitChannels *mChatServiceMockInitChannels) Set(f func(ctx context.Context) (err error)) *ChatServiceMock {
	if mmInitChannels.defaultExpectation != nil {
		mmInitChannels.mock.t.Fatalf("Default expectation is already set for the ChatService.InitChannels method")
	}

	if len(mmInitChannels.expectations) > 0 {
		mmInitChannels.mock.t.Fatalf("Some expectations are already set for the ChatService.InitChannels method")
	}

	mmInitChannels.mock.funcInitChannels = f
	return mmInitChannels.mock
}

// When sets expectation for the ChatService.InitChannels which will trigger the result defined by the following
// Then helper
func (mmInitChannels *mChatServiceMockInitChannels) When(ctx context.Context) *ChatServiceMockInitChannelsExpectation {
	if mmInitChannels.mock.funcInitChannels != nil {
		mmInitChannels.mock.t.Fatalf("ChatServiceMock.InitChannels mock is already set by Set")
	}

	expectation := &ChatServiceMockInitChannelsExpectation{
		mock:   mmInitChannels.mock,
		params: &ChatServiceMockInitChannelsParams{ctx},
	}
	mmInitChannels.expectations = append(mmInitChannels.expectations, expectation)
	return expectation
}

// Then sets up ChatService.InitChannels return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockInitChannelsExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockInitChannelsResults{err}
	return e.mock
}

// Times sets number of times ChatService.InitChannels should be invoked
func (mmInitChannels *mChatServiceMockInitChannels) Times(n uint64) *mChatServiceMockInitChannels {
	if n == 0 {
		mmInitChannels.mock.t.Fatalf("Times of ChatServiceMock.InitChannels mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInitChannels.expectedInvocations, n)
	return mmInitChannels
}

func (mmInitChannels *mChatServiceMockInitChannels) invocationsDone() bool {
	if len(mmInitChannels.expectations) == 0 && mmInitChannels.defaultExpectation == nil && mmInitChannels.mock.funcInitChannels == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInitChannels.mock.afterInitChannelsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInitChannels.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InitChannels implements service.ChatService
func (mmInitChannels *ChatServiceMock) InitChannels(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmInitChannels.beforeInitChannelsCounter, 1)
	defer mm_atomic.AddUint64(&mmInitChannels.afterInitChannelsCounter, 1)

	if mmInitChannels.inspectFuncInitChannels != nil {
		mmInitChannels.inspectFuncInitChannels(ctx)
	}

	mm_params := ChatServiceMockInitChannelsParams{ctx}

	// Record call args
	mmInitChannels.InitChannelsMock.mutex.Lock()
	mmInitChannels.InitChannelsMock.callArgs = append(mmInitChannels.InitChannelsMock.callArgs, &mm_params)
	mmInitChannels.InitChannelsMock.mutex.Unlock()

	for _, e := range mmInitChannels.InitChannelsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInitChannels.InitChannelsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInitChannels.InitChannelsMock.defaultExpectation.Counter, 1)
		mm_want := mmInitChannels.InitChannelsMock.defaultExpectation.params
		mm_want_ptrs := mmInitChannels.InitChannelsMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockInitChannelsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInitChannels.t.Errorf("ChatServiceMock.InitChannels got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInitChannels.t.Errorf("ChatServiceMock.InitChannels got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInitChannels.InitChannelsMock.defaultExpectation.results
		if mm_results == nil {
			mmInitChannels.t.Fatal("No results are set for the ChatServiceMock.InitChannels")
		}
		return (*mm_results).err
	}
	if mmInitChannels.funcInitChannels != nil {
		return mmInitChannels.funcInitChannels(ctx)
	}
	mmInitChannels.t.Fatalf("Unexpected call to ChatServiceMock.InitChannels. %v", ctx)
	return
}

// InitChannelsAfterCounter returns a count of finished ChatServiceMock.InitChannels invocations
func (mmInitChannels *ChatServiceMock) InitChannelsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitChannels.afterInitChannelsCounter)
}

// InitChannelsBeforeCounter returns a count of ChatServiceMock.InitChannels invocations
func (mmInitChannels *ChatServiceMock) InitChannelsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitChannels.beforeInitChannelsCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.InitChannels.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInitChannels *mChatServiceMockInitChannels) Calls() []*ChatServiceMockInitChannelsParams {
	mmInitChannels.mutex.RLock()

	argCopy := make([]*ChatServiceMockInitChannelsParams, len(mmInitChannels.callArgs))
	copy(argCopy, mmInitChannels.callArgs)

	mmInitChannels.mutex.RUnlock()

	return argCopy
}

// MinimockInitChannelsDone returns true if the count of the InitChannels invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockInitChannelsDone() bool {
	if m.InitChannelsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InitChannelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InitChannelsMock.invocationsDone()
}

// MinimockInitChannelsInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockInitChannelsInspect() {
	for _, e := range m.InitChannelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.InitChannels with params: %#v", *e.params)
		}
	}

	afterInitChannelsCounter := mm_atomic.LoadUint64(&m.afterInitChannelsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InitChannelsMock.defaultExpectation != nil && afterInitChannelsCounter < 1 {
		if m.InitChannelsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.InitChannels")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.InitChannels with params: %#v", *m.InitChannelsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitChannels != nil && afterInitChannelsCounter < 1 {
		m.t.Error("Expected call to ChatServiceMock.InitChannels")
	}

	if !m.InitChannelsMock.invocationsDone() && afterInitChannelsCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.InitChannels but found %d calls",
			mm_atomic.LoadUint64(&m.InitChannelsMock.expectedInvocations), afterInitChannelsCounter)
	}
}

type mChatServiceMockSendMessage struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockSendMessageExpectation
	expectations       []*ChatServiceMockSendMessageExpectation

	callArgs []*ChatServiceMockSendMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatServiceMockSendMessageExpectation specifies expectation struct of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectation struct {
	mock      *ChatServiceMock
	params    *ChatServiceMockSendMessageParams
	paramPtrs *ChatServiceMockSendMessageParamPtrs
	results   *ChatServiceMockSendMessageResults
	Counter   uint64
}

// ChatServiceMockSendMessageParams contains parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParams struct {
	ctx     context.Context
	chatID  string
	message *model.Message
}

// ChatServiceMockSendMessageParamPtrs contains pointers to parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParamPtrs struct {
	ctx     *context.Context
	chatID  *string
	message **model.Message
}

// ChatServiceMockSendMessageResults contains results of the ChatService.SendMessage
type ChatServiceMockSendMessageResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mChatServiceMockSendMessage) Optional() *mChatServiceMockSendMessage {
	mmSendMessage.optional = true
	return mmSendMessage
}

// Expect sets up expected params for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Expect(ctx context.Context, chatID string, message *model.Message) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.paramPtrs != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by ExpectParams functions")
	}

	mmSendMessage.defaultExpectation.params = &ChatServiceMockSendMessageParams{ctx, chatID, message}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectCtxParam1(ctx context.Context) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSendMessage
}

// ExpectChatIDParam2 sets up expected param chatID for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectChatIDParam2(chatID string) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.chatID = &chatID

	return mmSendMessage
}

// ExpectMessageParam3 sets up expected param message for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectMessageParam3(message *model.Message) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.message = &message

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Inspect(f func(ctx context.Context, chatID string, message *model.Message)) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Return(err error) *ChatServiceMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServiceMockSendMessageResults{err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatService.SendMessage method
func (mmSendMessage *mChatServiceMockSendMessage) Set(f func(ctx context.Context, chatID string, message *model.Message) (err error)) *ChatServiceMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatService.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatService.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the ChatService.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServiceMockSendMessage) When(ctx context.Context, chatID string, message *model.Message) *ChatServiceMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServiceMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ChatServiceMockSendMessageParams{ctx, chatID, message},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatService.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockSendMessageExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockSendMessageResults{err}
	return e.mock
}

// Times sets number of times ChatService.SendMessage should be invoked
func (mmSendMessage *mChatServiceMockSendMessage) Times(n uint64) *mChatServiceMockSendMessage {
	if n == 0 {
		mmSendMessage.mock.t.Fatalf("Times of ChatServiceMock.SendMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessage.expectedInvocations, n)
	return mmSendMessage
}

func (mmSendMessage *mChatServiceMockSendMessage) invocationsDone() bool {
	if len(mmSendMessage.expectations) == 0 && mmSendMessage.defaultExpectation == nil && mmSendMessage.mock.funcSendMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessage.mock.afterSendMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessage implements service.ChatService
func (mmSendMessage *ChatServiceMock) SendMessage(ctx context.Context, chatID string, message *model.Message) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, chatID, message)
	}

	mm_params := ChatServiceMockSendMessageParams{ctx, chatID, message}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockSendMessageParams{ctx, chatID, message}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

			if mm_want_ptrs.message != nil && !minimock.Equal(*mm_want_ptrs.message, mm_got.message) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter message, want: %#v, got: %#v%s\n", *mm_want_ptrs.message, mm_got.message, minimock.Diff(*mm_want_ptrs.message, mm_got.message))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServiceMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, chatID, message)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServiceMock.SendMessage. %v %v %v", ctx, chatID, message)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServiceMockSendMessage) Calls() []*ChatServiceMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServiceMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockSendMessageDone() bool {
	if m.SendMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageMock.invocationsDone()
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage with params: %#v", *e.params)
		}
	}

	afterSendMessageCounter := mm_atomic.LoadUint64(&m.afterSendMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && afterSendMessageCounter < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && afterSendMessageCounter < 1 {
		m.t.Error("Expected call to ChatServiceMock.SendMessage")
	}

	if !m.SendMessageMock.invocationsDone() && afterSendMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.SendMessage but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageMock.expectedInvocations), afterSendMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConnectInspect()

			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockInitChannelsInspect()

			m.MinimockSendMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConnectDone() &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockInitChannelsDone() &&
		m.MinimockSendMessageDone()
}
