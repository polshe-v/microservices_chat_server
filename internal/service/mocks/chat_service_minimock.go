// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/polshe-v/microservices_chat_server/internal/model"
)

// ChatServiceMock implements service.ChatService
type ChatServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcConnect          func(chatID string, username string, stream model.Stream) (err error)
	inspectFuncConnect   func(chatID string, username string, stream model.Stream)
	afterConnectCounter  uint64
	beforeConnectCounter uint64
	ConnectMock          mChatServiceMockConnect

	funcCreate          func(ctx context.Context, chat *model.Chat) (s1 string, err error)
	inspectFuncCreate   func(ctx context.Context, chat *model.Chat)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mChatServiceMockCreate

	funcDelete          func(ctx context.Context, id string) (err error)
	inspectFuncDelete   func(ctx context.Context, id string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mChatServiceMockDelete

	funcInitChannels          func(ctx context.Context) (err error)
	inspectFuncInitChannels   func(ctx context.Context)
	afterInitChannelsCounter  uint64
	beforeInitChannelsCounter uint64
	InitChannelsMock          mChatServiceMockInitChannels

	funcSendMessage          func(ctx context.Context, chatID string, message *model.Message) (err error)
	inspectFuncSendMessage   func(ctx context.Context, chatID string, message *model.Message)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServiceMockSendMessage
}

// NewChatServiceMock returns a mock for service.ChatService
func NewChatServiceMock(t minimock.Tester) *ChatServiceMock {
	m := &ChatServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ConnectMock = mChatServiceMockConnect{mock: m}
	m.ConnectMock.callArgs = []*ChatServiceMockConnectParams{}

	m.CreateMock = mChatServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*ChatServiceMockCreateParams{}

	m.DeleteMock = mChatServiceMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ChatServiceMockDeleteParams{}

	m.InitChannelsMock = mChatServiceMockInitChannels{mock: m}
	m.InitChannelsMock.callArgs = []*ChatServiceMockInitChannelsParams{}

	m.SendMessageMock = mChatServiceMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServiceMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceMockConnect struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockConnectExpectation
	expectations       []*ChatServiceMockConnectExpectation

	callArgs []*ChatServiceMockConnectParams
	mutex    sync.RWMutex
}

// ChatServiceMockConnectExpectation specifies expectation struct of the ChatService.Connect
type ChatServiceMockConnectExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockConnectParams
	results *ChatServiceMockConnectResults
	Counter uint64
}

// ChatServiceMockConnectParams contains parameters of the ChatService.Connect
type ChatServiceMockConnectParams struct {
	chatID   string
	username string
	stream   model.Stream
}

// ChatServiceMockConnectResults contains results of the ChatService.Connect
type ChatServiceMockConnectResults struct {
	err error
}

// Expect sets up expected params for ChatService.Connect
func (mmConnect *mChatServiceMockConnect) Expect(chatID string, username string, stream model.Stream) *mChatServiceMockConnect {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &ChatServiceMockConnectExpectation{}
	}

	mmConnect.defaultExpectation.params = &ChatServiceMockConnectParams{chatID, username, stream}
	for _, e := range mmConnect.expectations {
		if minimock.Equal(e.params, mmConnect.defaultExpectation.params) {
			mmConnect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmConnect.defaultExpectation.params)
		}
	}

	return mmConnect
}

// Inspect accepts an inspector function that has same arguments as the ChatService.Connect
func (mmConnect *mChatServiceMockConnect) Inspect(f func(chatID string, username string, stream model.Stream)) *mChatServiceMockConnect {
	if mmConnect.mock.inspectFuncConnect != nil {
		mmConnect.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.Connect")
	}

	mmConnect.mock.inspectFuncConnect = f

	return mmConnect
}

// Return sets up results that will be returned by ChatService.Connect
func (mmConnect *mChatServiceMockConnect) Return(err error) *ChatServiceMock {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	if mmConnect.defaultExpectation == nil {
		mmConnect.defaultExpectation = &ChatServiceMockConnectExpectation{mock: mmConnect.mock}
	}
	mmConnect.defaultExpectation.results = &ChatServiceMockConnectResults{err}
	return mmConnect.mock
}

// Set uses given function f to mock the ChatService.Connect method
func (mmConnect *mChatServiceMockConnect) Set(f func(chatID string, username string, stream model.Stream) (err error)) *ChatServiceMock {
	if mmConnect.defaultExpectation != nil {
		mmConnect.mock.t.Fatalf("Default expectation is already set for the ChatService.Connect method")
	}

	if len(mmConnect.expectations) > 0 {
		mmConnect.mock.t.Fatalf("Some expectations are already set for the ChatService.Connect method")
	}

	mmConnect.mock.funcConnect = f
	return mmConnect.mock
}

// When sets expectation for the ChatService.Connect which will trigger the result defined by the following
// Then helper
func (mmConnect *mChatServiceMockConnect) When(chatID string, username string, stream model.Stream) *ChatServiceMockConnectExpectation {
	if mmConnect.mock.funcConnect != nil {
		mmConnect.mock.t.Fatalf("ChatServiceMock.Connect mock is already set by Set")
	}

	expectation := &ChatServiceMockConnectExpectation{
		mock:   mmConnect.mock,
		params: &ChatServiceMockConnectParams{chatID, username, stream},
	}
	mmConnect.expectations = append(mmConnect.expectations, expectation)
	return expectation
}

// Then sets up ChatService.Connect return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockConnectExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockConnectResults{err}
	return e.mock
}

// Connect implements service.ChatService
func (mmConnect *ChatServiceMock) Connect(chatID string, username string, stream model.Stream) (err error) {
	mm_atomic.AddUint64(&mmConnect.beforeConnectCounter, 1)
	defer mm_atomic.AddUint64(&mmConnect.afterConnectCounter, 1)

	if mmConnect.inspectFuncConnect != nil {
		mmConnect.inspectFuncConnect(chatID, username, stream)
	}

	mm_params := ChatServiceMockConnectParams{chatID, username, stream}

	// Record call args
	mmConnect.ConnectMock.mutex.Lock()
	mmConnect.ConnectMock.callArgs = append(mmConnect.ConnectMock.callArgs, &mm_params)
	mmConnect.ConnectMock.mutex.Unlock()

	for _, e := range mmConnect.ConnectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmConnect.ConnectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConnect.ConnectMock.defaultExpectation.Counter, 1)
		mm_want := mmConnect.ConnectMock.defaultExpectation.params
		mm_got := ChatServiceMockConnectParams{chatID, username, stream}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmConnect.t.Errorf("ChatServiceMock.Connect got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmConnect.ConnectMock.defaultExpectation.results
		if mm_results == nil {
			mmConnect.t.Fatal("No results are set for the ChatServiceMock.Connect")
		}
		return (*mm_results).err
	}
	if mmConnect.funcConnect != nil {
		return mmConnect.funcConnect(chatID, username, stream)
	}
	mmConnect.t.Fatalf("Unexpected call to ChatServiceMock.Connect. %v %v %v", chatID, username, stream)
	return
}

// ConnectAfterCounter returns a count of finished ChatServiceMock.Connect invocations
func (mmConnect *ChatServiceMock) ConnectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnect.afterConnectCounter)
}

// ConnectBeforeCounter returns a count of ChatServiceMock.Connect invocations
func (mmConnect *ChatServiceMock) ConnectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConnect.beforeConnectCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.Connect.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmConnect *mChatServiceMockConnect) Calls() []*ChatServiceMockConnectParams {
	mmConnect.mutex.RLock()

	argCopy := make([]*ChatServiceMockConnectParams, len(mmConnect.callArgs))
	copy(argCopy, mmConnect.callArgs)

	mmConnect.mutex.RUnlock()

	return argCopy
}

// MinimockConnectDone returns true if the count of the Connect invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockConnectDone() bool {
	for _, e := range m.ConnectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnect != nil && mm_atomic.LoadUint64(&m.afterConnectCounter) < 1 {
		return false
	}
	return true
}

// MinimockConnectInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockConnectInspect() {
	for _, e := range m.ConnectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.Connect with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnectCounter) < 1 {
		if m.ConnectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.Connect")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.Connect with params: %#v", *m.ConnectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConnect != nil && mm_atomic.LoadUint64(&m.afterConnectCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.Connect")
	}
}

type mChatServiceMockCreate struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockCreateExpectation
	expectations       []*ChatServiceMockCreateExpectation

	callArgs []*ChatServiceMockCreateParams
	mutex    sync.RWMutex
}

// ChatServiceMockCreateExpectation specifies expectation struct of the ChatService.Create
type ChatServiceMockCreateExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockCreateParams
	results *ChatServiceMockCreateResults
	Counter uint64
}

// ChatServiceMockCreateParams contains parameters of the ChatService.Create
type ChatServiceMockCreateParams struct {
	ctx  context.Context
	chat *model.Chat
}

// ChatServiceMockCreateResults contains results of the ChatService.Create
type ChatServiceMockCreateResults struct {
	s1  string
	err error
}

// Expect sets up expected params for ChatService.Create
func (mmCreate *mChatServiceMockCreate) Expect(ctx context.Context, chat *model.Chat) *mChatServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &ChatServiceMockCreateParams{ctx, chat}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ChatService.Create
func (mmCreate *mChatServiceMockCreate) Inspect(f func(ctx context.Context, chat *model.Chat)) *mChatServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ChatService.Create
func (mmCreate *mChatServiceMockCreate) Return(s1 string, err error) *ChatServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ChatServiceMockCreateResults{s1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the ChatService.Create method
func (mmCreate *mChatServiceMockCreate) Set(f func(ctx context.Context, chat *model.Chat) (s1 string, err error)) *ChatServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ChatService.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ChatService.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the ChatService.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mChatServiceMockCreate) When(ctx context.Context, chat *model.Chat) *ChatServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	expectation := &ChatServiceMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &ChatServiceMockCreateParams{ctx, chat},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ChatService.Create return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCreateExpectation) Then(s1 string, err error) *ChatServiceMock {
	e.results = &ChatServiceMockCreateResults{s1, err}
	return e.mock
}

// Create implements service.ChatService
func (mmCreate *ChatServiceMock) Create(ctx context.Context, chat *model.Chat) (s1 string, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, chat)
	}

	mm_params := ChatServiceMockCreateParams{ctx, chat}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := ChatServiceMockCreateParams{ctx, chat}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ChatServiceMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ChatServiceMock.Create")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, chat)
	}
	mmCreate.t.Fatalf("Unexpected call to ChatServiceMock.Create. %v %v", ctx, chat)
	return
}

// CreateAfterCounter returns a count of finished ChatServiceMock.Create invocations
func (mmCreate *ChatServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ChatServiceMock.Create invocations
func (mmCreate *ChatServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mChatServiceMockCreate) Calls() []*ChatServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ChatServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.Create")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.Create")
	}
}

type mChatServiceMockDelete struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockDeleteExpectation
	expectations       []*ChatServiceMockDeleteExpectation

	callArgs []*ChatServiceMockDeleteParams
	mutex    sync.RWMutex
}

// ChatServiceMockDeleteExpectation specifies expectation struct of the ChatService.Delete
type ChatServiceMockDeleteExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockDeleteParams
	results *ChatServiceMockDeleteResults
	Counter uint64
}

// ChatServiceMockDeleteParams contains parameters of the ChatService.Delete
type ChatServiceMockDeleteParams struct {
	ctx context.Context
	id  string
}

// ChatServiceMockDeleteResults contains results of the ChatService.Delete
type ChatServiceMockDeleteResults struct {
	err error
}

// Expect sets up expected params for ChatService.Delete
func (mmDelete *mChatServiceMockDelete) Expect(ctx context.Context, id string) *mChatServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatServiceMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &ChatServiceMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the ChatService.Delete
func (mmDelete *mChatServiceMockDelete) Inspect(f func(ctx context.Context, id string)) *mChatServiceMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by ChatService.Delete
func (mmDelete *mChatServiceMockDelete) Return(err error) *ChatServiceMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatServiceMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ChatServiceMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the ChatService.Delete method
func (mmDelete *mChatServiceMockDelete) Set(f func(ctx context.Context, id string) (err error)) *ChatServiceMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the ChatService.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the ChatService.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the ChatService.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mChatServiceMockDelete) When(ctx context.Context, id string) *ChatServiceMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	expectation := &ChatServiceMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ChatServiceMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up ChatService.Delete return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockDeleteExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockDeleteResults{err}
	return e.mock
}

// Delete implements service.ChatService
func (mmDelete *ChatServiceMock) Delete(ctx context.Context, id string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := ChatServiceMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := ChatServiceMockDeleteParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ChatServiceMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ChatServiceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to ChatServiceMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished ChatServiceMock.Delete invocations
func (mmDelete *ChatServiceMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ChatServiceMock.Delete invocations
func (mmDelete *ChatServiceMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mChatServiceMockDelete) Calls() []*ChatServiceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ChatServiceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.Delete")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.Delete")
	}
}

type mChatServiceMockInitChannels struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockInitChannelsExpectation
	expectations       []*ChatServiceMockInitChannelsExpectation

	callArgs []*ChatServiceMockInitChannelsParams
	mutex    sync.RWMutex
}

// ChatServiceMockInitChannelsExpectation specifies expectation struct of the ChatService.InitChannels
type ChatServiceMockInitChannelsExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockInitChannelsParams
	results *ChatServiceMockInitChannelsResults
	Counter uint64
}

// ChatServiceMockInitChannelsParams contains parameters of the ChatService.InitChannels
type ChatServiceMockInitChannelsParams struct {
	ctx context.Context
}

// ChatServiceMockInitChannelsResults contains results of the ChatService.InitChannels
type ChatServiceMockInitChannelsResults struct {
	err error
}

// Expect sets up expected params for ChatService.InitChannels
func (mmInitChannels *mChatServiceMockInitChannels) Expect(ctx context.Context) *mChatServiceMockInitChannels {
	if mmInitChannels.mock.funcInitChannels != nil {
		mmInitChannels.mock.t.Fatalf("ChatServiceMock.InitChannels mock is already set by Set")
	}

	if mmInitChannels.defaultExpectation == nil {
		mmInitChannels.defaultExpectation = &ChatServiceMockInitChannelsExpectation{}
	}

	mmInitChannels.defaultExpectation.params = &ChatServiceMockInitChannelsParams{ctx}
	for _, e := range mmInitChannels.expectations {
		if minimock.Equal(e.params, mmInitChannels.defaultExpectation.params) {
			mmInitChannels.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInitChannels.defaultExpectation.params)
		}
	}

	return mmInitChannels
}

// Inspect accepts an inspector function that has same arguments as the ChatService.InitChannels
func (mmInitChannels *mChatServiceMockInitChannels) Inspect(f func(ctx context.Context)) *mChatServiceMockInitChannels {
	if mmInitChannels.mock.inspectFuncInitChannels != nil {
		mmInitChannels.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.InitChannels")
	}

	mmInitChannels.mock.inspectFuncInitChannels = f

	return mmInitChannels
}

// Return sets up results that will be returned by ChatService.InitChannels
func (mmInitChannels *mChatServiceMockInitChannels) Return(err error) *ChatServiceMock {
	if mmInitChannels.mock.funcInitChannels != nil {
		mmInitChannels.mock.t.Fatalf("ChatServiceMock.InitChannels mock is already set by Set")
	}

	if mmInitChannels.defaultExpectation == nil {
		mmInitChannels.defaultExpectation = &ChatServiceMockInitChannelsExpectation{mock: mmInitChannels.mock}
	}
	mmInitChannels.defaultExpectation.results = &ChatServiceMockInitChannelsResults{err}
	return mmInitChannels.mock
}

// Set uses given function f to mock the ChatService.InitChannels method
func (mmInitChannels *mChatServiceMockInitChannels) Set(f func(ctx context.Context) (err error)) *ChatServiceMock {
	if mmInitChannels.defaultExpectation != nil {
		mmInitChannels.mock.t.Fatalf("Default expectation is already set for the ChatService.InitChannels method")
	}

	if len(mmInitChannels.expectations) > 0 {
		mmInitChannels.mock.t.Fatalf("Some expectations are already set for the ChatService.InitChannels method")
	}

	mmInitChannels.mock.funcInitChannels = f
	return mmInitChannels.mock
}

// When sets expectation for the ChatService.InitChannels which will trigger the result defined by the following
// Then helper
func (mmInitChannels *mChatServiceMockInitChannels) When(ctx context.Context) *ChatServiceMockInitChannelsExpectation {
	if mmInitChannels.mock.funcInitChannels != nil {
		mmInitChannels.mock.t.Fatalf("ChatServiceMock.InitChannels mock is already set by Set")
	}

	expectation := &ChatServiceMockInitChannelsExpectation{
		mock:   mmInitChannels.mock,
		params: &ChatServiceMockInitChannelsParams{ctx},
	}
	mmInitChannels.expectations = append(mmInitChannels.expectations, expectation)
	return expectation
}

// Then sets up ChatService.InitChannels return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockInitChannelsExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockInitChannelsResults{err}
	return e.mock
}

// InitChannels implements service.ChatService
func (mmInitChannels *ChatServiceMock) InitChannels(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmInitChannels.beforeInitChannelsCounter, 1)
	defer mm_atomic.AddUint64(&mmInitChannels.afterInitChannelsCounter, 1)

	if mmInitChannels.inspectFuncInitChannels != nil {
		mmInitChannels.inspectFuncInitChannels(ctx)
	}

	mm_params := ChatServiceMockInitChannelsParams{ctx}

	// Record call args
	mmInitChannels.InitChannelsMock.mutex.Lock()
	mmInitChannels.InitChannelsMock.callArgs = append(mmInitChannels.InitChannelsMock.callArgs, &mm_params)
	mmInitChannels.InitChannelsMock.mutex.Unlock()

	for _, e := range mmInitChannels.InitChannelsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInitChannels.InitChannelsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInitChannels.InitChannelsMock.defaultExpectation.Counter, 1)
		mm_want := mmInitChannels.InitChannelsMock.defaultExpectation.params
		mm_got := ChatServiceMockInitChannelsParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInitChannels.t.Errorf("ChatServiceMock.InitChannels got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInitChannels.InitChannelsMock.defaultExpectation.results
		if mm_results == nil {
			mmInitChannels.t.Fatal("No results are set for the ChatServiceMock.InitChannels")
		}
		return (*mm_results).err
	}
	if mmInitChannels.funcInitChannels != nil {
		return mmInitChannels.funcInitChannels(ctx)
	}
	mmInitChannels.t.Fatalf("Unexpected call to ChatServiceMock.InitChannels. %v", ctx)
	return
}

// InitChannelsAfterCounter returns a count of finished ChatServiceMock.InitChannels invocations
func (mmInitChannels *ChatServiceMock) InitChannelsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitChannels.afterInitChannelsCounter)
}

// InitChannelsBeforeCounter returns a count of ChatServiceMock.InitChannels invocations
func (mmInitChannels *ChatServiceMock) InitChannelsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInitChannels.beforeInitChannelsCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.InitChannels.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInitChannels *mChatServiceMockInitChannels) Calls() []*ChatServiceMockInitChannelsParams {
	mmInitChannels.mutex.RLock()

	argCopy := make([]*ChatServiceMockInitChannelsParams, len(mmInitChannels.callArgs))
	copy(argCopy, mmInitChannels.callArgs)

	mmInitChannels.mutex.RUnlock()

	return argCopy
}

// MinimockInitChannelsDone returns true if the count of the InitChannels invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockInitChannelsDone() bool {
	for _, e := range m.InitChannelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitChannelsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitChannelsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitChannels != nil && mm_atomic.LoadUint64(&m.afterInitChannelsCounter) < 1 {
		return false
	}
	return true
}

// MinimockInitChannelsInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockInitChannelsInspect() {
	for _, e := range m.InitChannelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.InitChannels with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InitChannelsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInitChannelsCounter) < 1 {
		if m.InitChannelsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.InitChannels")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.InitChannels with params: %#v", *m.InitChannelsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInitChannels != nil && mm_atomic.LoadUint64(&m.afterInitChannelsCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.InitChannels")
	}
}

type mChatServiceMockSendMessage struct {
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockSendMessageExpectation
	expectations       []*ChatServiceMockSendMessageExpectation

	callArgs []*ChatServiceMockSendMessageParams
	mutex    sync.RWMutex
}

// ChatServiceMockSendMessageExpectation specifies expectation struct of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectation struct {
	mock    *ChatServiceMock
	params  *ChatServiceMockSendMessageParams
	results *ChatServiceMockSendMessageResults
	Counter uint64
}

// ChatServiceMockSendMessageParams contains parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParams struct {
	ctx     context.Context
	chatID  string
	message *model.Message
}

// ChatServiceMockSendMessageResults contains results of the ChatService.SendMessage
type ChatServiceMockSendMessageResults struct {
	err error
}

// Expect sets up expected params for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Expect(ctx context.Context, chatID string, message *model.Message) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	mmSendMessage.defaultExpectation.params = &ChatServiceMockSendMessageParams{ctx, chatID, message}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Inspect(f func(ctx context.Context, chatID string, message *model.Message)) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Return(err error) *ChatServiceMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServiceMockSendMessageResults{err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatService.SendMessage method
func (mmSendMessage *mChatServiceMockSendMessage) Set(f func(ctx context.Context, chatID string, message *model.Message) (err error)) *ChatServiceMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatService.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatService.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the ChatService.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServiceMockSendMessage) When(ctx context.Context, chatID string, message *model.Message) *ChatServiceMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServiceMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ChatServiceMockSendMessageParams{ctx, chatID, message},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatService.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockSendMessageExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockSendMessageResults{err}
	return e.mock
}

// SendMessage implements service.ChatService
func (mmSendMessage *ChatServiceMock) SendMessage(ctx context.Context, chatID string, message *model.Message) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, chatID, message)
	}

	mm_params := ChatServiceMockSendMessageParams{ctx, chatID, message}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_got := ChatServiceMockSendMessageParams{ctx, chatID, message}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServiceMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, chatID, message)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServiceMock.SendMessage. %v %v %v", ctx, chatID, message)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServiceMockSendMessage) Calls() []*ChatServiceMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServiceMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockSendMessageDone() bool {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatServiceMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		m.t.Error("Expected call to ChatServiceMock.SendMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockConnectInspect()

			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockInitChannelsInspect()

			m.MinimockSendMessageInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockConnectDone() &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockInitChannelsDone() &&
		m.MinimockSendMessageDone()
}
